<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="Habibutsu">

    <title>Ковариантность и контравариантность</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
    <!-- Optional theme -->
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css">
    <!-- Latest compiled and minified JavaScript -->
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <!-- Custom styles for this template -->
    <link href="static/theme.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy this line! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="static/highlight/styles/solarized_dark.css">
    <script src="static/highlight/highlight.pack.js"></script>
    <script type="text/javascript">
        hljs.initHighlightingOnLoad();
        //hljs.configure({useBR: true});
        $('div.code').each(function(i, e) {hljs.highlightBlock(e)});
    </script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-51121455-1', 'habibutsu.github.io');
        ga('send', 'pageview');
    </script>
</head>

<body role="document">

    <!-- Fixed navbar -->
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Alexander Verbitsky</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.html">Главная</a></li>
            <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Заметки<b class="caret"></b></a>
                <ul class="dropdown-menu">
                    <li><a href="linux_syscall.html">Системный вызов в Linux</a></li>
                    <li><a href="#">Модель памяти</a></li>
                    <li class="dropdown-header">Шпаргалка по Git</li>
                </ul>
            </li>
            <li><a href="slides.html">Слайды</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="container theme-showcase" role="main">

    <div class="row well">

        <div class="col-sm-8 blog-main">
            <div class="blog-post">

<img style="width:40%" src="static/illusion.jpg">
<h2 class="blog-post-title">Ковариантность и контравариантность</h2>
<p class="blog-post-meta">Май 28, 2014 <a href="#">Habibutsu</a> <b style="color: red">(Черновик)</b></p>
<h3>Содержание</h4>
<ul>
    <li><a href="#introduction">Введение</a></li>
    <li><a href="#math">Математика</a></li>
    <li><a href="#category_theory">Теория категорий</a></li>
    <li><a href="#programming">Программирование</a></li>
    <ul>
        <li><a href="#java">Java</a></li>
        <li><a href="#java">C#</a></li>
        <li><a href="#java">С++</a></li>
        <li><a href="#java">Scala</a></li>
        <li><a href="#java">Haskell</a></li>
    </ul>
    <li><a href="#links">Ссылки</a></li>
</ul>

<h3 class="blog-post-title">Введение</h3>
<p>
    С развитием компьютерной науки (Computer Science) именно как отдельной дисциплины она все больше начинает впитывать в себя терминов и определений из смежных областей (математика, логика и др.). <i>Ковариантность и контравариантность</i> - одно из таких понятий. В данной заметке в кратком виде приводится определение данных терминов с точки зрения математики, теории категорий и программирования.
</p>
<h3 class="blog-post-title">Математика</h3>
<p>
Определим три отображения для целых чисел:
</p>
<ul>
    <li>D : x &rarr; x + x (удвоение)</li>
    <li>N : x &rarr; 0 - x (отрицание)</li>
    <li>S : x &rarr; x * x (возведение в квадрат)</li>
</ul>
<p>
Рассмотрим отношение порядка в двух различных пространствах:
</p>

<ul>
    <li>x &le; y</li>
    <li>F(x) &le; F(y)</li>
</ul>

<p>
Будет ли оно выполняться при переходе от одного пространства к другому?
</p>
<p>    
    Удвоение
    <ul>
        <li>(x &le; y) = (D(x) &le; D(y)) - выполняется</li>
    </ul>
    Пример: 2 &le; 3 = (D(2) &le; D(3)) = 4 &le; 6<br>
    Отношение порядка выполняется - <i>вариантность</i>
</p>
<p>
    Отрицание:
    <ul>
        <li>(x &le; y) = (N(x) &le; N(y)) - не выполняется</li>
        <li>(x &le; y) = (N(y) &le; N(x)) - выполняется</li>
    </ul>
    Пример: 2 &le; 3 &ne; (N(2) &le; N(3)) = -2 &le; -3, однако 2 &le; 3 = (N(3) &le; N(2)) = -3 &le; -2<br>
    Отношение порядка меняется на потивоположное - <i>контравариантность</i>
</p>
<p>
    Возведение в квадрат:
    <ul>
        <li>(x &le; y) = (S(x) &le; S(y)) - не выполняется</li>
        <li>(x &le; y) = (S(y) &le; S(x)) - не выполняется</li>
    </ul>
    Пример: -3 &le; -2 &ne; (S(-3) &le; S(-2)) = 6 &le; 4, и 2 &le; 3 &ne; (S(3) &le; S(2)) = 6 &le; 4<br>
    Отношение порядка не выполняется в обоих случаях- <i>инвариантность</i>
</p>
<p>
    В качестве еще одного примера рассмотрим функцию f: x &rarr; sin(x)<br>
    Если систему координат сдвинуть на <i>+a</i> по оси X, то график функции сместится в противоположном направлении на <i>-a</i> т.е. при смене базиса (системы координат) компоненты изменяются с помощью преобразования обратного преобразованию базиса - функция является <i>контравариантной</i> относительно оси X. В то же время если сдвинуть систему координат по оси Y а <i>+a</i>, то график функции сместится в том же направленннии - функция является <i>ковариантной</i> относительно оси Y.
<center>
    <img class="img-thumbnail" style="width: 80%" src="static/fun_sin.jpg"><br>
</center>
</p>

<h3 class="blog-post-title">Теория категорий</h3>
<p>
    Взаимосвязь между теорией категорий и теорией типов можно выразить следующим образом [1]:
    <ul>
        <li>Объект - Тип данных</li>
        <li>Морфизм - Программа</li>
    </ul>
</p>
<p>
    В качестве стандартного примера рассмотрим функтор степени множеств: P: Set &rarr; Set [7].
</p>
<p>
    <i>Ковариантный</i> функтор степени P: Set &rarr; Set ставит в соответсвие каждому множеству A его множество-степень P(A), а каждой функии f: A &rarr; B - отоброжение P(f): P(A) &rarr; P(B), переводящий любое подмножетсво X &sube; A в его образ f(X) &sube; B.
</p>
<p>
    Если f: a &rarr; a * a, тогда множество A = [1, 2] посредством f: A &rarr; B будет отображено в B = [1, 4], при этом PA = [[], [1], [2], [1, 2]] в случае если Pf = f: a &rarr; a * a будет отображено в PB = [[], [1], [4], [1, 4]]
</p>
<p>
    <i>Контравариантный</i> функтор степени P: Set &rarr; Set ставит в соответсвие каждому множеству A его множество-степень P(A), а каждой функии f: A &rarr; B - отоброжение P(f): P(B) &rarr; P(A), переводящий любое подмножетсво X &sube; B в его образ f<sup>-1</sup>(X) &sube; A.
</p>
<p>
    Если f: a &rarr; a * a, тогда множество A = [1, 2] посредством f: A &rarr; B будет отображено в B = [1, 4], при этом PB = [[], [1], [4], [1, 4]] в случае если Pf = f<sup>-1</sup>: a &rarr; a * a будет отображено в PA = [[], [1], [2], [1, 2]]
</p>

<h3 class="blog-post-title">Программирование</h3>

<p>
    Для возможности рассуждать об отношении порядка между типами (тип/подтип) необходимо какое-то формальное правило. Такое правило было предложено Барбарой Лисков в 1987 году на конференции в основном докладе под названием "Абстракция данных и иерархия" <a href="#link6">[7]</a>.
    <div class="alert alert-info">
    <strong>Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP)</strong>
    <p>
    Пусть q(x) является свойством, верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S является подтипом типа T.</p>
    </div>
    <center>
        <img class="img-thumbnail" style="width: 80%" src="static/LSP.jpg"><br>
    </center>
</p>
<p>
    Другими словами, если некоторый тип <b>S</b> можно подставить везде, где используется тип <b>Т</b> и поведение программы не будет меняться, то тип <b>T</b> является базовым по отношению к <b>S</b> при этом подразумевается, что тип <b>S</b> поддерживает все те же операции что и тип <b>T</b> и при этом все операции типа <b>S</b> требуют меньшего, а предоставляют большее чем соответсвующие операции в <b>T</b>.
</p>
<p>
    Исходя из этого определения можно дать понятия ко-/контр-вариантных типов
    <ul>
        <li>
            <b>Ковариантность</b> - случай когда более конкретный тип <b>S</b> может быть подставлен вместо более обобщенного типа <b>Т</b>
        </li>
        <li>
            <b>Контрвариантность</b> - случай когда более общий тип <b>Т</b> может быть подставлен вместо более конкретного типа <b>S</b>
        </li>
        <li>
            <b>Инвариантность</b> - случай когда подставлять можно только определенный тип
        </li>
    </ul>
</p>
<p>
    Другими словами при ковариантности иерархия наследования сохраняется в прямом направлении, при контравариантности она меняется на противоположное, а при инвариантности не определена.
</p>
<p>

    Обычно ковариантность и контравариантность смешиваются в одном типе, например при определении типа произвольной функции которая является контравариантной по своим входным аргументам и ковариантной по своим выходным аргументам т.к. аргументы это нечо что требуется в то время как результат это нечто что предоставляется.
</p>
<p>
    Еще одним важным следствием из вышеприведенных определений является то, что ковариантность типо-безопасна для операций чтения, а контравариантность для операций записи.
</p>
<p>
    Чтобы все это уяснить, лучше обратиться к реальным примерам.
</p>
<h4>Java</h4>
<p>
    Возьмем следующую иерархию типов:
    <center>
        <img class="img-thumbnail" src="static/type_hierarchy.png"><br>
    </center>
</p>
<p>
    Т.к. массивы в Java решено было сделать ковариантными, то вместе с отношением тип <i>Rectangle</i> является подтипом <i>Shape</i>, вводится отношение тип <i>Array[Rectangle]</i> является подтипом <i>Array[Shape]</i>. Такой подход был обусловлен желанием разработчиков Java предоставить возможность реализовывать обобщенные функции (когда обобщенных типов еще не было в языке) в которые можно передавать произвольный ссылочный тип.

<pre class="java"><code>public class TestArray {
    public static void main(String[] args){
        String[] strArray = new String[] {"string1", "string2", "string3"};
        print(strArray);
    }

    public static void print(Object[] objectArray){
        for (Object v : objectArray)
            System.out.print(v + "\n");
    }
}</code></pre>
<pre class="bash"><code>$ javac TestArray.java 
$ java TestArray 
string1
string2
string3
</code></pre>
<p>
Однако это приводит к тому, что допускается не типо-безопасное присваивание и соответсвенно некорректное поведение на runtime:
    <pre class="java"><code>public class TestArray {
    public static void main(String[] args){
        String[] strArray = new String[] {"string1", "string2", "string3"};
        Object[] objectArray;
        objectArray = strArray;
        objectArray[2] = 123;
    }
}</code></pre>
<pre class="bash"><code>$ javac TestArray.java 
$ java TestArray 
Exception in thread "main" java.lang.ArrayStoreException: java.lang.Integer
    at TestArray.main(TestArray.java:6)
</code></pre>
</p>
<p>
    С появлением обощенных типов необходимость в таком подходе отпала, но для обратной совместимости поведение было сохранено.
</p>
<p>
    Чтобы объявить аргументы ковариантными в параметре типа можно использовать включевое слово <b>extends</b>
<pre class="java"><code>public TestInterface covariant(List&lt;? extends TestInterface> ilist) {
   return ilist.remove(0);
 }
</code></pre>

Чтобы объявить аргументы контрвариантными в параметре типа можно использовать включевое слово <b>super</b>
<pre class="java"><code>public void contravariant(List&lt;? super TestClass> clist, TestClass c) {
   clist.add(c);
}
</code></pre>
<h4>C#</h4>
<h4>C++</h4>

Ковариантность
<pre class="c++"><code>class X {};
class Y : public X {};
class Z : public Y {};

class A {
public:
  virtual Y *foo() { return new Y(); }
};

class B : public A {
public:
  virtual X *foo() { return new X(); }
};
</code></pre>
<pre class="bash"><code>$ g++ -W -Wall -ansi -pedantic -c foo.cc
foo.cc:12: error: invalid covariant return type for ‘virtual X* B::foo()'
foo.cc:7: error:   overriding ‘virtual Y* A::foo()’
</code></pre>

Контравариантность
<pre class="с++"><code>class X {};
class Y : public X {};
class Z : public Y {};

class A {
public:
  virtual void foo(Y &y) { }
};

class B : public A {
public:
  virtual void foo(Z &z) { }
};


int main() {
  B b;
  Y y;
  Z z;
  
  b.foo(y);
  b.foo(z);
  return 0;
}
</code></pre>
<pre class="bash"><code>$ g++ -W -Wall -ansi -pedantic  foo.cc
foo.cc: In function ‘int main()’:
foo.cc:24: error: no matching function for call to ‘B::foo(Y&)’
foo.cc:14: note: candidates are: virtual void B::foo(Z&)
</code></pre>

<h4>Scala</h4>
<h4>Haskell</h4>
<p>
    Любая функция является контравариантной по своим входным аргументам и ковариантной по своим выходным аргументам.
</p>
<h3 class="blog-post-title">Ссылки</h3>
<a name="links"></a>
<p>
<ul>
    <li>[1]
        <a href="http://www.ams.org/journals/tran/1945-058-00/S0002-9947-1945-0013131-6/S0002-9947-1945-0013131-6.pdf">
            General theory of natural equivalences.
        </a>
    </li>
    <li>[2]
        <a href="http://arxiv.org/abs/0903.0340">
            Physics, Topology, Logic and Computation: A Rosetta Stone (John C. Baez, Mike Stay)
        </a>
    </li>
    <li>[3]
        <a href="http://category_theory.livejournal.com/12189.html">
            Физика, топология, логика и теория вычислений: Розеттский камень (Дж. К. Баез, М. Стэй) - Перевод Р. Душкин
        </a>
    </li>
    <li>[4]
        <a href="http://en.wikipedia.org/wiki/Category_theory">
            Category Theory - Wikipedia, the free encyclopedia
        </a>
    </li>
    <li>[5]
        <a href="http://plato.stanford.edu/entries/category-theory/">
            Category Theory - Stanford Encyclopedia of Philosophy
        </a>
    </li>
    <li>[6]
        <a name="link7" href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">
            Теория типов — Википедия
        </a>
    </li>
    <li>[7]
        Топосы. Категорный анализ логики - Голдблатт Р., 1983 г.
    </li>
    <li>[8]
        Категории для работающего математика - Сандерс Маклейн, 2004 г.
    </li>
    <li>[9]
        <a href="http://www.cs.iastate.edu/~hridesh/teaching/362/07/01/papers/p50-liskov.pdf">
            Data abstraction and hierarchy - Liskov, Barbara
        </a>
    </li>
    <li>[10]
        <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">
            Covariance and contravariance (computer science) - Wikipedia
        </a>
    </li>
    <li>[11]
        <a href="http://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html">
            24 Days of Hackage: contravariant
        </a>
    </li>
</ul>
</p>
            </div>
            <!-- /blog-post -->
        </div>
        <!-- /blog-main -->

        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">

            <div class="panel panel-default">
                <div class="panel-heading">
                  <h4 class="panel-title" style="font-size: 18px">Архив</h4>
                </div>
                <div class="panel-body">
                    <ol class="list-unstyled">
                      <li><a href="#">Январь 2014</a></li>
                    </ol>
                </div>
            </div>

            <div class="sidebar-module well">
                <h4>Мой профиль</h4>
                <ol class="list-unstyled">
                  <li><a href="https://plus.google.com/+AlexanderVerbitsky">G+</a></li>
                  <li><a href="https://github.com/habibutsu">GitHub</a></li>
                  <li><a href="#">Linkedin</a></li>
                </ol>
            </div>

        </div><!-- /.blog-sidebar -->

    </div><!-- /.row -->

    </div> <!-- /container -->
</body>
</html>